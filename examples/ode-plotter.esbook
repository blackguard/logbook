{
    "nb_type": "esbook",
    "nb_version": "2.0.0",
    "elements": [
        {
            "id": "id-bb5229ec-1f75-468e-b649-b2fbc986e158",
            "input": "// autoeval",
            "output": [],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        },
        {
            "id": "id-65afe6c9-67ab-4646-a5ae-a30abfeba7a4",
            "input": "This notebook will be automatically evaluated when loaded.\nOnce evaluation completes, click the Go button to start.\n$ $\nEquations and parameters may be modified in code in the last element.\nTo see the effect of modifications, evaluate the last element, or\nsimply re-evaluate the entire notebook (from the menu: Element->Eval notebook)\n",
            "output": [
                {
                    "type": "text",
                    "text": "This notebook will be automatically evaluated when loaded.\nOnce evaluation completes, click the Go button to start.\n$ $\nEquations and parameters may be modified in code in the last element.\nTo see the effect of modifications, evaluate the last element, or\nsimply re-evaluate the entire notebook (from the menu: Element->Eval notebook)\n"
                }
            ],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        },
        {
            "id": "id-62586896-26db-456f-a932-010b74369e72",
            "input": "// autohide\n\nclass WorkerPool {\n    constructor(worker_count=navigator.hardwareConcurrency) {\n        Object.defineProperties(this, {\n            worker_count: {\n                value: worker_count,\n                enumerable: true,\n            },\n        });\n        this._workers = [];\n        this._update_pool();\n    }\n\n    get workers (){\n        if (this._workers.some(w => w.terminated)) {\n            this._update_pool();\n        }\n        return this._workers;\n    }\n\n    _update_pool() {\n        this._workers = this._workers.filter(w => !w.terminated);\n        for (let i = this._workers.length; i < this.worker_count; i++) {\n            this._workers.push(create_worker());\n        }\n    }\n};\n\nvars({ worker_pool: this.eval_context.worker_pool ?? new WorkerPool() });",
            "output": [],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        },
        {
            "id": "id-221137d4-4cc0-401e-9d12-80f78781140d",
            "input": "// autohide\nconst {\n    Plotly,\n} = await import('./output-handlers/plotly.js');\n\nconst html = `\n<style>\n    #ode_plotter_info_display {\n        display: flex;\n        gap: 2rem;\n    }\n\n    #ode_plotter_play_controls {\n        padding-top: 0.5rem;\n        padding-bottom: 0.5rem;\n    }\n\n    #ode_plotter_controls {\n        width: fit-content;\n    }\n    #ode_plotter_controls div * {\n        vertical-align: middle;\n    }\n\n    #ode_plotter_adjustments {\n        display: grid;\n        grid-template-columns: max-content max-content;\n        gap: 0.5rem;\n    }\n    #ode_plotter_adjustments label {\n        justify-self: end;\n    }\n\n    #ode_plotter_config_display {\n        width: fit-content;\n        font-family: monospace;\n    }\n\n    .ode_plotter_display {\n        margin-left: 0.1rem;\n        padding: 0 0.5rem;\n        background-color: #eee;\n    }\n\n    .hidden {\n        display: none;\n    }\n</style>\n\n<div id=\"ode_plotter_play_controls\">\n    <button id=\"ode_plotter_go\">Go</button>\n    <button id=\"ode_plotter_pause\" class=\"hidden\">Pause</button>\n</div>\n<div id=\"ode_plotter_info_display\">\n    <div id=\"ode_plotter_controls\">\n        <div id=\"ode_plotter_adjustments\">\n            <label for=\"points_per_loop\">Time steps per loop</label>\n            <div>\n                <input id=\"points_per_loop\" type=\"range\" min=\"1\" max=\"10000\" value=\"1000\">\n                <span id=\"points_per_loop_display\" class=\"ode_plotter_display\"></span>\n            </div>\n            <label for=\"loop_delay\">Loop delay</label>\n            <div>\n                <input id=\"loop_delay\" type=\"range\" min=\"0\" max=\"500\" value=\"0\">\n                <span id=\"loop_delay_display\" class=\"ode_plotter_display\"></span> ms\n            </div>\n            <label for=\"points_shown\">Time steps shown</label>\n            <div>\n                <input id=\"points_shown\" type=\"range\" min=\"0\" max=\"100000\" step=\"10\" value=\"20000\">\n                <span id=\"points_shown_display\" class=\"ode_plotter_display\"></span>\n            </div>\n            <label for=\"point_count_display\">Total time steps</label>\n            <div>\n                <span id=\"point_count_display\" class=\"ode_plotter_display\"></span>\n            </div>\n            <label class=\"hidden\" for=\"point_cloud_loop_display\">Point cloud steps</label>\n            <div class=\"hidden\">\n                <span id=\"point_cloud_loop_display\" class=\"ode_plotter_display\"></span>\n            </div>\n            <label class=\"hidden\" for=\"point_cloud_points_per_loop\">PC steps per loop</label>\n            <div class=\"hidden\">\n                <input id=\"point_cloud_points_per_loop\" type=\"range\" min=\"1\" max=\"100\" value=\"1\">\n                <span id=\"point_cloud_points_per_loop_display\" class=\"ode_plotter_display\"></span>\n            </div>\n        </div>\n    </div>\n    <div id=\"ode_plotter_config_display\"></div>\n</div>\n<div id=\"ode_plotter_plot\"></div>\n`;\n\nfunction setup(the_output_context, the_equation_def) {\n    the_output_context.create_output_element().innerHTML = html;\n\n    const plot_el = document.getElementById('ode_plotter_plot');\n\n    const go_button    = document.getElementById('ode_plotter_go');\n    const pause_button = document.getElementById('ode_plotter_pause');\n\n    function set_go_button_state(running) {\n        if (running) {\n            go_button.innerText = 'Stop';\n        } else {\n            go_button.innerText = 'Go';\n        }\n    }\n\n    function set_pause_button_state(paused, running) {\n        pause_button.innerText = paused ? 'Resume' : 'Pause';\n        if (running) {\n            pause_button.classList.remove('hidden');\n        } else {\n            pause_button.classList.add('hidden');\n        }\n    }\n    set_go_button_state(false);\n    set_pause_button_state(false, false);\n\n    const points_per_loop_el     = document.getElementById('points_per_loop');\n    const loop_delay_el          = document.getElementById('loop_delay');\n    const points_shown_el        = document.getElementById('points_shown');\n    const point_count_display_el = document.getElementById('point_count_display');\n\n    const point_cloud_loop_display_el           = document.getElementById('point_cloud_loop_display');\n    const point_cloud_loop_display_parent_el    = point_cloud_loop_display_el.parentElement;\n    const point_cloud_loop_display_label_el     = document.querySelector('label[for=\"point_cloud_loop_display\"]');\n    const point_cloud_points_per_loop_label_el  = document.querySelector('label[for=\"point_cloud_points_per_loop\"]');\n    const point_cloud_points_per_loop_el        = document.getElementById('point_cloud_points_per_loop');\n    const point_cloud_points_per_loop_parent_el = point_cloud_points_per_loop_el.parentElement;\n\n    for (const range_id of [\n        'points_per_loop',\n        'loop_delay',\n        'points_shown',\n        'point_cloud_points_per_loop',\n    ]) {\n        const range_el   = document.getElementById(range_id);\n        const display_el = document.getElementById(`${range_id}_display`);\n        display_el.innerText = range_el.value;\n        range_el.addEventListener('input', (event) => {\n            display_el.innerText = range_el.value;\n        });\n    }\n\n    function set_point_cloud_loop_display(visible, value='') {\n        point_cloud_loop_display.innerText = value;\n        const affected_els = [\n            point_cloud_loop_display_parent_el,\n            point_cloud_loop_display_label_el,\n            point_cloud_points_per_loop_label_el,\n            point_cloud_points_per_loop_parent_el,\n        ];\n        if (visible) {\n            for (const el of affected_els) {\n                el.classList.remove('hidden');\n            }\n        } else {\n            for (const el of affected_els) {\n                el.classList.add('hidden');\n            }\n        }\n    }\n    set_point_cloud_loop_display(false);\n\n    const config_display_el = document.getElementById('ode_plotter_config_display');\n\n    function display_config(config) {\n        if (!config) {\n            config_display_el.classList.add('hidden');\n            config_display_el.innerText = '';\n        } else {\n            config_display_el.classList.remove('hidden');\n            const { dt, x0, params, skip, steps, point_cloud } = config;\n            const lines = [];\n            lines.push('--- CONFIG ---');\n            lines.push(`dt: ${dt}`);\n            lines.push(`x0: [${x0.join(', ')}]`);\n            if (params) {\n                let params_str;\n                if (typeof params === 'object') {\n                    try {\n                        params_str = JSON.stringify(params);\n                    } catch (_) {\n                        params_str = params.toString();\n                    }\n                } else {\n                    params_str = params.toString();\n                }\n                lines.push(`params: ${params_str}`);\n            }\n            if (skip) {\n                lines.push(`skip: ${skip}`);\n            }\n            if (steps) {\n                lines.push(`steps: ${steps}`);\n            }\n            if (point_cloud) {\n                const { n, c, r, dt:pc_dt=dt, steps:pc_steps } = point_cloud;\n                lines.push(`--- point cloud ---`);\n                lines.push(`n: ${n}, c: [${c.join(', ')}], dt: ${pc_dt}${pc_steps ? `, steps:${pc_steps}` : ''}}`);\n            }\n            config_display_el.innerText = lines.join('\\n');\n        }\n    }\n    display_config();\n\n    const plot_height = 720;\n    plot_el.style = `height: ${plot_height}px`;\n\n    const Generator = Object.getPrototypeOf(function*(){}).constructor;\n\n    function validate_f(f) {\n        if (typeof f !== 'function') {\n            throw new Error('f must be a function');\n        }\n    }\n    function validate_integrator(integrator) {\n        if (typeof integrator !== 'function') {\n            throw new Error('integrator must be a function');\n        }\n    }\n    function validate_point_cloud(point_cloud) {\n        if ( typeof point_cloud !== 'object') {\n            throw new Error('point_cloud must be an object')\n        }\n        const { n, c, r, dt, steps } = point_cloud;\n        if (typeof n === 'undefined') {\n            throw new Error('point_cloud.n must be defined');\n        } else if (!Number.isInteger(n) || n <= 0) {\n            throw new Error('point_cloud.n must be a positive integer');\n        }\n        if (typeof c === 'undefined') {\n            throw new Error('point_cloud.c must be defined');\n        } else if (!Array.isArray(c) || c.length <= 0 || c.some(e => (typeof e !== 'number'))) {\n            throw new Error(`point_cloud.c must be a non-empty array of numbers`);\n        }\n        if (typeof r === 'undefined') {\n            throw new Error('point_cloud.r must be defined');\n        } else if (typeof r !== 'number' || r <= 0) {\n            throw new Error('point_cloud.r must be a positive number');\n        }\n        if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt <= 0)) {\n            throw new Error(`point_cloud.dt must be a positive number`);\n        }\n        if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps < 0)) {\n            throw new Error('steps point_cloudmust be a non-negative integer');\n        }\n    }\n    function validate_config(config, structure_name='config') {\n        if ( typeof config !== 'object') {\n            throw new Error(`${structure_name} must be an object`)\n        }\n        const { integrator, dt, x0, skip, steps, point_cloud } = config;  // params is unrestricted\n        if (integrator) {\n            validate_integrator(integrator);\n        }\n        if (typeof dt !== 'undefined' && (typeof dt !== 'number' || dt <= 0)) {\n            throw new Error(`${structure_name}.dt must be a positive number`);\n        }\n        if (typeof x0 !== 'undefined' &&\n             (!Array.isArray(x0) || x0.length <= 0 || x0.some(e => (typeof e !== 'number'))) ) {\n            throw new Error(`${structure_name}.x0 must be a non-empty array of numbers`);\n        }\n        if (typeof skip !== 'undefined' && (!Number.isInteger(skip) || skip < 0)) {\n            throw new Error(`${structure_name}.skip must be a non-negative integer`);\n        }\n        if (typeof steps !== 'undefined' && (!Number.isInteger(steps) || steps < 0)) {\n            throw new Error(`${structure_name}.steps must be a non-negative integer`);\n        }\n        if (point_cloud) {\n            validate_point_cloud(point_cloud);\n        }\n    }\n    function validate_equation_def(equation_def) {\n        if ( typeof equation_def !== 'object') {\n            throw new Error('equation definition must be an object')\n        }\n        validate_config(equation_def, 'equation_def');  // equation_def is a subclass of config\n        const { title, f, iter, iter_delay } = equation_def;\n        if (typeof title !== 'undefined' && typeof title !== 'string') {\n            throw new Error('equation_def.title must be a string');\n        }\n        if (iter) {\n            const iterator_fn = iter[Symbol.iterator];\n            if ( (typeof iterator_fn !== 'undefined' && typeof iterator_fn !== 'function') &&\n                 !(iter instanceof Generator) ) {\n                throw new Error('equation_def.iter must be an iterable or a generator function');\n            }\n        }\n        if (typeof iter_delay !== 'undefined' && (typeof iter_delay !== 'number' || iter_delay < 0)) {\n            throw new Error('equation_def.iter_delay must be a non-negative number');\n        }\n        if (typeof f === 'undefined') {\n            throw new Error('equation_def.f must be defined');\n        } else {\n            validate_f(f);\n        }\n    }\n\n    let runner;\n    const set_running_state = (running) => {\n        runner?.stop();\n        if (running) {\n            const new_runner = new Runner(the_equation_def);\n            runner = new_runner;\n            new_runner.done.then(\n                () => {\n                    if (!new_runner.stopped) {\n                        set_running_state(false);\n                    }\n                },\n                error => {\n                    if (!new_runner.stopped) {\n                        set_running_state(false);\n                    }\n                }\n            );\n            point_count_display_el.innerText = '';\n            go_button.innerText = 'Stop';\n            document.getElementById('ode_plotter_play_controls').scrollIntoView();\n        } else {\n            runner = undefined;\n            go_button.innerText = 'Go';\n        }\n    }\n    go_button.addEventListener('click', async (event) => {\n        set_running_state(!runner);\n    });\n\n    class Runner {\n        constructor(equation_def) {\n            validate_equation_def(equation_def);\n\n            this._equation_def = equation_def;\n\n            this._xs = [];\n            this._ys = [];\n            this._zs = [];\n            this._cs = [];\n\n            this._gdata = [{\n                name: 'equation',\n                type: 'scatter3d',\n                mode: 'lines',\n                x: this._xs,\n                y: this._ys,\n                z: this._zs,\n                opacity: 1,\n                line: {\n                    width: 3,\n                    color: this._cs,\n                    reversescale: false,\n                },\n            }];\n            this._extrema_trace = {\n                name: 'extrema',\n                showlegend: false,\n                type: 'scatter3d',\n                mode: 'markers',\n                x: [],\n                y: [],\n                z: [],\n                marker: {\n                    color: 'rgba(0, 0, 0, 0.01)',\n                    size: 1,\n                },\n            };\n            this._gdata.push(this._extrema_trace);\n\n\n            display_config();\n            set_point_cloud_loop_display(false);\n\n            this._mouse_paused = false;\n            this._the_plot_el_mousedown_handler = (event) => { this._mouse_paused = true; };\n            this._the_plot_el_mousedown_handler_options = { capture: true };\n            this._the_plot_el_mouseup_handler = (event) => { this._mouse_paused = false; };\n            this._the_plot_el_mouseup_handler_options = { capture: true };\n            plot_el.addEventListener(\n                'mousedown',\n                this._the_plot_el_mousedown_handler,\n                this._the_plot_el_mousedown_handler_options\n            );\n            plot_el.addEventListener(\n                'mouseup',\n                this._the_plot_el_mouseup_handler,\n                this._the_plot_el_mouseup_handler_options\n            );\n\n            this._button_paused = false;\n            this._the_pause_button_click_handler = (event) => {\n                this._button_paused = !this._button_paused;\n                set_pause_button_state(this._button_paused, this._running);\n            };\n            this._the_pause_button_click_handler_options = {};\n            pause_button.addEventListener(\n                'click',\n                this._the_pause_button_click_handler,\n                this._the_pause_button_click_handler_options\n            );\n\n            this._stopped = false;\n            this._running = false;\n\n            this._done = new Promise(async (resolve, reject) => {\n                this._running = true;\n                set_go_button_state(this._running);\n                set_pause_button_state(this._button_paused, this._running);\n\n                try {\n                    const { title, f, iter_delay } = this._equation_def;\n\n                    let { iter } = this._equation_def;\n                    if (!iter) {\n                        iter = [{}];  // one empty config\n                    } else if (iter instanceof Generator) {\n                        iter = iter(this._equation_def);\n                    }\n                    // iter is now an iterable\n\n                    let first_iteration = true;\n                    for (const config of iter) {\n                        if (!this._running) {\n                            break;\n                        }\n\n                        this._clear_data();\n\n                        const merged_config = {\n                            ...this._equation_def,  // this._equation_def may contain config properties\n                            ...config,              // config properties override those in this._equation_def\n                        };\n                        validate_config(merged_config);\n\n                        if (iter_delay && !first_iteration) {\n                            await new Promise(resolve => setTimeout(resolve, iter_delay));\n                        }\n                        first_iteration = false;\n\n                        const { integrator, dt, x0, params, skip=0, steps=Infinity, point_cloud } = merged_config;\n                        if (typeof integrator === 'undefined') {\n                            throw new Error('integrator was not specified');\n                        }\n                        if (typeof dt === 'undefined') {\n                            throw new Error('dt was not specified');\n                        }\n                        if (typeof x0 === 'undefined') {\n                            throw new Error('x0 was not specified');\n                        }\n\n                        display_config(merged_config);\n\n                        let x = [ ...x0 ];  // copy x0 to insulate from mutation\n                        if (skip <= 0) {\n                            this._add(x);\n                        }\n\n                        let plot_fn = Plotly.newPlot;\n                        let point_count = 0;\n                        while (this._running && point_count < skip+steps) {\n                            if (!this.paused) {\n                                const points_per_loop = parseInt(points_per_loop_el.value);\n                                for (let lp = 0; lp < points_per_loop; lp++) {\n                                    if (!this._running) {\n                                        break;\n                                    }\n                                    x = integrator(dt, f, x, params);\n                                    point_count++;\n                                    if (point_count >= skip) {\n                                        this._add(x);\n                                    }\n                                    if (point_count >= skip+steps) {\n                                        break;\n                                    }\n                                }\n\n                                this._trim_data();\n\n                                if (point_count >= skip) {\n                                    this._draw_data(plot_fn);\n                                    plot_fn = Plotly.react;\n                                }\n\n                                point_count_display_el.innerText = point_count;\n                            }\n\n                            if (point_count < skip+steps) {\n                                const loop_delay = parseInt(loop_delay_el.value);\n                                await new Promise(resolve => setTimeout(resolve, loop_delay));\n                            }\n                        }\n\n                        // Done plotting graph for this config.\n                        // Finally, run its point cloud, if any.\n                        if (this._running && point_cloud) {\n                            await this._run_point_cloud(f, merged_config);\n                        }\n                    }\n\n                    // done\n                    resolve();\n\n                } catch (err) {\n                    console.error(err.message, err.stack);\n                    alert(`${err.message}\\n\\n${err.stack}`);\n                    reject(err);\n                }\n            });\n        }\n\n        get running (){ return this._running; }\n        get paused  (){ return this._mouse_paused || this._button_paused; }\n        get stopped (){ return this._stopped; }\n        get done    (){ return this._done; }\n\n        stop() {\n            this._stopped = true;\n            this._running = false;\n            plot_el.removeEventListener(\n                'mousedown',\n                this._the_plot_el_mousedown_handler,\n                this._the_plot_el_mousedown_handler_options\n            );\n            plot_el.removeEventListener(\n                'mouseup',\n                this._the_plot_el_mouseup_handler,\n                this._the_plot_el_mouseup_handler_options\n            );\n            pause_button.removeEventListener(\n                'click',\n                this._the_pause_button_click_handler,\n                this._the_pause_button_click_handler_options\n            );\n            this._button_paused = false;\n            set_pause_button_state(this._button_paused, this._running);\n        }\n\n        // internal\n\n        _clear_data() {\n            this._xs.splice(0, this._xs.length);\n            this._ys.splice(0, this._ys.length);\n            this._zs.splice(0, this._zs.length);\n            this._cs.splice(0, this._cs.length);\n        }\n\n        _trim_data() {\n            let limit = parseInt(points_shown_el.value);\n            if (isNaN(limit)) {\n                limit = 0;\n            }\n            if (this._xs.length > limit) {\n                this._xs.splice(0, this._xs.length-limit);\n                this._ys.splice(0, this._ys.length-limit);\n                this._zs.splice(0, this._zs.length-limit);\n                this._cs.splice(0, this._cs.length-limit);\n            }\n        }\n\n        _add([x, y, z], c=1) {\n            this._xs.push(x ?? 0);\n            this._ys.push(y ?? 0);\n            this._zs.push(z ?? 0);\n            this._cs.push(c);\n        }\n\n        _draw_data(plot_fn, no_update_revision=false) {\n            // update extrema\n            let values_seen = false;\n            let min_x = Infinity, max_x = -Infinity,\n                min_y = Infinity, max_y = -Infinity,\n                min_z = Infinity, max_z = -Infinity;\n            for (const trace of this._gdata) {\n                if (trace.x.length > 0 || trace.y.length > 0 || trace.z.length > 0) {\n                    values_seen = true;\n                }\n\n                for (const v of trace.x) {\n                    if (v < min_x) {\n                        min_x = v;\n                    }\n                    if (v > max_x) {\n                        max_x = v;\n                    }\n                }\n                for (const v of trace.y) {\n                    if (v < min_y) {\n                        min_y = v;\n                    }\n                    if (v > max_y) {\n                        max_y = v;\n                    }\n                }\n                for (const v of trace.z) {\n                    if (v < min_z) {\n                        min_z = v;\n                    }\n                    if (v > max_z) {\n                        max_z = v;\n                    }\n                }\n            }\n            if (values_seen) {\n                this._extrema_trace.x = [ min_x, max_x ];\n                this._extrema_trace.y = [ min_y, max_y ];\n                this._extrema_trace.z = [ min_z, max_z ];\n            }\n\n            // update layout\n            const layout = {\n                height: plot_height,\n            };\n            if (!no_update_revision) {\n                layout.datarevision = Date.now();\n            }\n            // note: plot_el._fullLayout is undocumented...\n            if (plot_el._fullLayout?.scene?.camera) {\n                layout.scene = {\n                    camera: plot_el._fullLayout.scene.camera,\n                };\n            }\n            if (this._equation_def?.title) {\n                layout.title = this._equation_def.title;\n            }\n            plot_fn(plot_el, this._gdata, layout);\n        }\n\n        async _run_point_cloud(f, config) {\n            const { integrator, dt, x0, params, point_cloud } = config;\n            const { n, c, r, dt:pc_dt=dt, steps=Infinity } = point_cloud;\n\n            const ArrayType = Float64Array;\n\n            set_point_cloud_loop_display(true, '');\n\n            // config contains point_cloud\n            // assume config has already been validated\n            if (!this._gdata) {\n                throw new Error('unexpected: !this._gdata');\n            }\n\n            // set up workers\n            const worker_count = worker_pool.workers.length;\n            const points_per_worker = Math.floor(n / worker_count);\n            const worker_descs = [ ...worker_pool.workers ].map((worker, index) => {\n                const start = index*points_per_worker;\n                const end   = (index >= worker_count-1) ? n : (start + points_per_worker);\n\n                const point_count = (end - start);\n\n                const pc_trace = {\n                    name: 'point cloud',\n                    showlegend: true,\n                    type: 'scatter3d',\n                    mode: 'markers',\n                    marker: {\n                        color: 'rgba(0, 0, 255, 1.0)',\n                        size: 1,\n                    },\n\n                    x: new ArrayType(point_count),\n                    y: new ArrayType(point_count),\n                    z: new ArrayType(point_count),\n                };\n\n                return {\n                    worker,\n                    index,\n                    point_count,\n                    pc_trace,\n                };\n            });\n            // initialize worker state, etc\n            for (const worker_desc of worker_descs) {\n                const worker   = worker_desc.worker;\n                const pc_trace = worker_desc.pc_trace;\n                // initialize pc_trace x, y, z arrays with the initial values\n                for (let i = 0; i < worker_desc.point_count; i++) {\n                    // generate the initial positions of the points\n                    // the points we generate here lie in a N-cube centered at c\n                    // with side length 2*r (where N = c.length).\n                    const [ x, y, z ] = c.map(xi => xi + r*2*(Math.random() - 0.5));\n                    pc_trace.x[i] = x;\n                    pc_trace.y[i] = y;\n                    pc_trace.z[i] = z;\n                }\n\n                // add new trace to the graphics data\n                this._gdata.push(pc_trace);\n\n                // set up worker state\n                await worker.eval(`\n                    const [ pc_dt, params, point_count, x, y, z ] = objects;\n                    Object.assign(globalThis, { pc_dt, params, point_count, x, y, z });\n                    globalThis.integrator = ${integrator.toString()};\n                    globalThis.f = ${f.toString()};\n                    globalThis.points_buffer = new ArrayBuffer(point_count*3*Float64Array.BYTES_PER_ELEMENT);\n                    globalThis.points = [];\n                    for (let i = 0; i < point_count; i++) {\n                        const point_view = new Float64Array(globalThis.points_buffer, i*3*Float64Array.BYTES_PER_ELEMENT, 3);\n                        point_view[0] = x[i];\n                        point_view[1] = y[i];\n                        point_view[2] = z[i];\n                        globalThis.points.push(point_view);\n                    }\n                `, pc_dt, params, worker_desc.point_count, pc_trace.x, pc_trace.y, pc_trace.z );\n            }\n\n            main_loop:\n            for (let s = 0; s < steps; /* s incremented below */) {\n                while (this.paused && this._running) {\n                    await new Promise(resolve => setTimeout(resolve), 100);\n                }\n                if (!this._running) {\n                    break main_loop;\n                }\n\n                // start calculations in workers first, then draw,\n                // then wait for calculations to complete\n\n                const iterations = parseInt(point_cloud_points_per_loop_el.value);\n                const calc_promise = Promise.all(\n                    worker_descs.map(worker_desc => {\n                        return worker_desc.worker\n                            .eval(`\n                                const [ iterations ] = objects;\n                                for (let iteration = 0; iteration < iterations; iteration++) {\n                                    for (let i = 0; i < point_count; i++) {\n                                        const point = points[i];\n                                        const p = integrator(pc_dt, f, point, params);\n                                        x[i] = point[0] = p[0];\n                                        y[i] = point[1] = p[1];\n                                        z[i] = point[2] = p[2];\n                                    }\n                                }\n                                return [ x, y, z ];\n                            `, iterations )\n                            .then(([ new_x, new_y, new_z ]) => {\n                                worker_desc.pc_trace.x = new_x;\n                                worker_desc.pc_trace.y = new_y;\n                                worker_desc.pc_trace.z = new_z;\n                            })\n                    })\n                );\n\n                this._draw_data(Plotly.react, true);\n\n                await calc_promise;\n                s += iterations;\n\n                set_point_cloud_loop_display(true, s+1);\n\n                const loop_delay = parseInt(loop_delay_el.value);\n                await new Promise(resolve => setTimeout(resolve, loop_delay));\n            }\n        }\n    }\n\n    setTimeout(() => {\n        document.getElementById('ode_plotter_adjustments').scrollIntoView(false);\n        go_button.focus();\n    }, 500);\n}\nvars({ setup });",
            "output": [],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        },
        {
            "id": "id-fd9204a7-389a-411f-84f1-7aba747a8505",
            "input": "// autohide\n\n// integrator:\n// f(x) returns xdot which has the same dimension as x\n// integrator returns a new x with the same dimension as the original\n\nfunction runge_kutta_integrator(dt, f, x, params) {\n    // This is an implementation of the fourth-order Runge-Kutta method\n    // as presented in Nonlinear Dynamics and Chaos, Second Edition, by\n    // Steven H. Strogatz, page 34.\n    // This implementation works for x with arbitrary dimension.\n    const k1 = f( x,                                params ).map( xidot => xidot*dt );\n    const k2 = f( x.map( (xi, i) => xi + k1[i]/2 ), params ).map( xidot => xidot*dt );\n    const k3 = f( x.map( (xi, i) => xi + k2[i]/2 ), params ).map( xidot => xidot*dt );\n    const k4 = f( x.map( (xi, i) => xi + k3[i]),    params ).map( xidot => xidot*dt );\n    return x.map( (xi, i) => xi + (k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6 );\n}\n\nvars({ runge_kutta_integrator });",
            "output": [],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        },
        {
            "id": "id-43590d42-c11b-4c60-b631-2ac66bf04d0d",
            "input": "//\nconst go = setup.bind(this, output_context);\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// EquationDef = Config + {\n//     title?: string,\n//     f: Function,\n//     iter?: iterable<Config>|generator<Config>(def: EquationDef),\n//     iter_delay?: number,\n// }\n//\n// Config = {\n//     integrator?: (dt: number, f: Function, x: number[], params: any) => number[],\n//     dt?: number,\n//     x0?: number[],\n//     params?: any,\n//     skip?:  integer,\n//     steps?: integer,\n//     point_cloud?: PointCloud,\n// }\n//\n// PointCloud = {\n//     n: integer,\n//     c: number[];\n//     r: number,\n//     dt?: number,\n//     steps?: integer,\n// }\n//\n// Function = (x: number[], params?: any) => number[]\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n// Definitions for some chaotic attractors provided by Dr. James P. Crutchfield\n// (one of the pioneers of Chaos Theory).\n//\n// For more information on chaotic attractors see Lecture 3 on the Roadmap page at the course:\n//\n//                 http://csc.ucdavis.edu/~chaos/courses/poci/\n\nconst integrator = runge_kutta_integrator;\n\nconst lorenz_def = {\n    title: 'Lorenz Attractor',\n    integrator,\n    dt: 0.005,\n    x0: [3, 3, 1],\n    f:  ( (sigma=10, r=28, b=8/3) =>\n          ([x, y, z]) => [  // this is f, and it takes 1 argument which is decomposed into [x, y, z]\n              sigma*(y - x),\n              r*x - y - x*z,\n              x*y - b*z,\n          ]\n        )()\n};\n\nconst owl_def = {\n    title: 'Owl Attractor',\n    integrator,\n    dt: 0.005,\n    x0: [3, 3, 1],\n    f:  ( (a=10, b=10, c=13) =>\n          ([x, y, z]) => [\n              -a*(x + y),\n              -y - b*x*z,\n              10*x*y + c,\n          ]\n        )()\n};\n\nconst rossler_def = {\n    title: 'Rössler Attractor',\n    integrator,\n    dt: 0.008,\n    x0: [10, 10, 1],\n    f:  ( (a=0.2, b=0.2, c=5.7) =>\n         ([x, y, z]) => [\n             -y - z,\n             x + a*y,\n             b + z*(x - c),\n         ]\n        )()\n};\n\nconst rikitake0_def = {  // see: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7517210/\n    title: 'Rikitake Attractor ( from https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7517210/ )',\n    integrator,\n    dt: 0.01,\n    x0: [3, 1, 6],\n    f:  ( (alpha=5, beta=2) =>\n          ([x, y, z]) => [\n              -beta*x + y*z,\n              -beta*y - alpha*x + x*z,\n              1 - x*y,\n          ]\n        )()\n};\n\nconst rikitake_def = {\n    title: 'Rikitake Attractor',\n    integrator,\n    dt: 0.009,\n    x0: [0.268, 2, 0],\n    f:  ( (a=1, b=3.75) =>\n          ([x, y, z]) => [\n              -a*x + z*y,\n              -a*y - (z - b)*x,\n              1 - x*y,\n          ]\n        )()\n};\n\nconst hyperchaos_def = {\n    title: 'Hyperchaos Attractor',\n    integrator,\n    dt: 0.005,\n    x0: [-20, 15, 0, 35],\n    f:  ( (a=0.25, b=-0.5, c=2.2, d=0.05) =>\n          ([x, y, z, w]) => [\n              -y - z,\n              x + a*y + w,\n              c + x*z,\n              b*z + d*w,\n          ]\n        )()\n};\n\nconst point_cloud_def = {\n    title: 'Lorenz Attractor With Point Cloud',\n    integrator,\n    dt: 0.005,\n    x0: [3, 3, 1],\n    params: { sigma: 10, r: 28, b: 8/3 },\n    f:  ([x, y, z], {sigma, r, b}) => [\n             sigma*(y - x),\n             r*x - y - x*z,\n             x*y - b*z,\n        ],\n    skip:  1000,\n    steps: 10000,\n    point_cloud: {\n        n: 10000,\n        c: [1, 1, 1],\n        r: 0.05,\n        dt: 0.05,\n    }\n};\n\n// set the equation definition to plot\n\n// go(lorenz_def);\n// go(owl_def);\n// go(rossler_def);\n// go(rikitake0_def);\n// go(rikitake_def);\n// go(hyperchaos_def);\n\ngo(point_cloud_def);\n",
            "output": [],
            "formatting_options": {
                "align": "left",
                "indent": "0em"
            }
        }
    ]
}